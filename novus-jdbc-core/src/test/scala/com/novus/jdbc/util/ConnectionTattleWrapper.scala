package com.novus.jdbc.util

import java.sql.{Savepoint, Connection}
import org.slf4j.LoggerFactory
import java.util.concurrent.Executor
import java.util.Properties
import java.util

/**
 * Test utility class to allow closer inspection of individual connection method calls.
 * @param c an instance of a JDBC connection
 */
class ConnectionTattleWrapper(c: Connection) extends Connection {

  val log = LoggerFactory getLogger this.getClass

  def abort(executor: Executor) { c.abort(executor) }

  def clearWarnings() { c.clearWarnings() }

  /**
   * Primitive sample usage to highlight who is calling close on the connection.
   */
  def close() {
    try {
      sys.error("who called this?")
    }
    catch {
      case e: Exception => {
        log.error(e.getMessage, e)
        c.close()
      }
    }
  }

  def commit() { c.commit() }

  def createArrayOf(typeName: String, elements: Array[AnyRef]) = c.createArrayOf(typeName, elements)

  def createBlob() = c.createBlob()

  def createClob() = c.createClob()

  def createNClob() = c.createNClob()

  def createSQLXML() = c.createSQLXML()

  def createStatement() = c.createStatement()

  def createStatement(resultSetType: Int, resultSetConcurrency: Int) = c.createStatement(resultSetType, resultSetConcurrency)

  def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)

  def createStruct(typeName: String, attributes: Array[AnyRef]) = c.createStruct(typeName, attributes)

  def getAutoCommit = c.getAutoCommit

  def getCatalog = c.getCatalog

  def getClientInfo = c.getClientInfo

  def getClientInfo(name: String) = c.getClientInfo(name)

  def getHoldability = c.getHoldability

  def getMetaData = c.getMetaData

  def getNetworkTimeout = c.getNetworkTimeout

  def getSchema = c.getSchema

  def getTransactionIsolation = c.getTransactionIsolation

  def getTypeMap = c.getTypeMap

  def getWarnings = c.getWarnings

  def isClosed = c.isClosed

  def isReadOnly = c.isReadOnly

  def isValid(timeout: Int) = c.isValid(timeout)

  def nativeSQL(sql: String) = c.nativeSQL(sql)

  def prepareCall(sql: String) = c.prepareCall(sql)

  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int) = c.prepareCall(sql, resultSetType, resultSetConcurrency)

  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = c.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

  def prepareStatement(sql: String) = c.prepareStatement(sql)

  def prepareStatement(sql: String, autoGeneratedKeys: Int) = c.prepareStatement(sql, autoGeneratedKeys)

  def prepareStatement(sql: String, columnIndexes: Array[Int]) = c.prepareStatement(sql, columnIndexes)

  def prepareStatement(sql: String, columnNames: Array[String]) = c.prepareStatement(sql, columnNames)

  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int) = c.prepareStatement(sql, resultSetType, resultSetConcurrency)

  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = c.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

  def releaseSavepoint(savepoint: Savepoint) { c.releaseSavepoint(savepoint) }

  def rollback() { c.rollback() }

  def rollback(savepoint: Savepoint) { c.rollback(savepoint) }

  def setAutoCommit(autoCommit: Boolean) { c.setAutoCommit(autoCommit) }

  def setCatalog(catalog: String) { c.setCatalog(catalog) }

  def setClientInfo(name: String, value: String) { c.setClientInfo(name, value) }

  def setClientInfo(properties: Properties) { c.setClientInfo(properties) }

  def setHoldability(holdability: Int) { c.setHoldability(holdability) }

  def setNetworkTimeout(executor: Executor, milliseconds: Int) { c.setNetworkTimeout(executor, milliseconds) }

  def setReadOnly(readOnly: Boolean) { c.setReadOnly(readOnly) }

  def setSavepoint() = c.setSavepoint()

  def setSavepoint(name: String) = c.setSavepoint(name)

  def setSchema(schema: String) { c.setSchema(schema) }

  def setTransactionIsolation(level: Int) { c.setTransactionIsolation(level) }

  def setTypeMap(map: util.Map[String, Class[_]]) { c.setTypeMap(map) }

  def isWrapperFor(iface: Class[_]) = c.isWrapperFor(iface)

  def unwrap[T](iface: Class[T]) = c.unwrap(iface)
}